// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema
// originally from https://github.com/heuriscode/GRDC-dashboard/blob/main/prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DB_URL")
}

model Region {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  sites  Site[]
  events Event[]

  @@map("region")
}

model Site {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  region       Region?     @relation(fields: [regionId], references: [id])
  regionId     Int         @map("region_id")
  consultant   Consultant? @relation(fields: [consultantId], references: [id])
  consultantId Int         @map("consultant_id")

  plotGroups PlotGroup[]
  groups     Group[]
  events     Event[]

  @@index([regionId])
  @@index([consultantId])
  @@map("site")
}

// Each site has a single consultant managing that site
// each consultant can manage multiple sites
model Consultant {
  id           Int      @id @default(autoincrement())
  name         String
  primaryUser  String   @map("primary_user")
  contactEmail String   @map("contact_email")
  contactPhone String   @map("contact_phone")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  users User[]
  sites Site[]

  @@index([name])
  @@map("consultant")
}

model User {
  id        Int       @id @default(autoincrement())
  firstName String    @map("first_name")
  lastName  String    @map("last_name")
  email     String
  role      UserRoles
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")

  consultant   Consultant? @relation(fields: [consultantId], references: [id])
  consultantId Int         @map("consultant_id")

  approved Boolean

  @@index([consultantId])
  @@index([firstName])
  @@index([role])
  @@map("user")
}

enum UserRoles {
  USER
  RESEARCHER
}

model PlotGroup {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  site   Site? @relation(fields: [siteId], references: [id])
  siteId Int   @map("site_id")
  // system String

  plots  Plot[]
  events Event[]

  @@index([siteId])
  @@index([name])
  @@map("plot_group")
}

model Plot {
  id        String   @unique
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  plotGroup   PlotGroup? @relation(fields: [plotGroupId], references: [id])
  plotGroupId Int        @map("plot_group_id")
  group       Group?     @relation(fields: [groupId], references: [id])
  groupId     Int        @map("group_id")

  events  Event[]
  actions Action[]

  @@index([plotGroupId])
  @@index([groupId])
  @@map("plot")
}

// This is just a temporary (each year) mapping of subplots to a 'group'
// subplots change their group membership each year
// most actions (e.g. crop type, fertiliser, harvest) are done at the group level
// so this is just a utility to more easily enter data so that group level actions flow down to subplots.
model Group {
  id        Int      @id @default(autoincrement())
  year      Int
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  site   Site? @relation(fields: [siteId], references: [id])
  siteId Int   @map("site_id")

  subplots      Plot[]
  group_actions Action[]

  @@index([siteId])
  @@index([year])
  @@map("group")
}

// Event can occur at region, site, plot and subplot level
model Event {
  id          Int       @id @default(autoincrement())
  description String
  date        DateTime
  type        EventType
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  region      Region?    @relation(fields: [regionId], references: [id])
  regionId    Int        @map("region_id")
  site        Site?      @relation(fields: [siteId], references: [id])
  siteId      Int        @map("site_id")
  plotGroup   PlotGroup? @relation(fields: [plotGroupId], references: [id])
  plotGroupId Int        @map("plot_group_id")
  plot        Plot?      @relation(fields: [plotId], references: [id])
  plotId      String     @map("plot_id")

  data Json

  // add event detail
  rainfall                     Float?
  windspeed                    Float?
  pests                        Boolean?
  temp_greater_than_30_degrees Boolean?
  herbicide_spray_drift        Boolean?
  other_event                  String?

  // add event impact (if any)
  crops_lost_percent            Float?
  crop_damage_estimated_percent Float?
  comments                      String?

  @@map("event") //map to events table
}

// Action model for planned trial activities (e.g. fertiliser application)
// actions can occur at a group or subplot level. If at group it automatically fills to subplot
// QUESTION - if an action occurs for a group, it happens for all subplot members of that group. Can we set it up so the group level action fills details for plots instead of groups?
model Action {
  id          Int      @id @default(autoincrement())
  description String
  date        DateTime
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  group       Group?   @relation(fields: [groupId], references: [id])
  groupId     Int      @map("group_id")
  plot        Plot?    @relation(fields: [plotId], references: [id])
  plotId      String   @map("plot_id")
  product     Product? @relation(fields: [productName], references: [name])
  productName String   @map("product_name")

  fertN                                   Float  @map("fert_n")
  fertP                                   Float  @map("fert_p")
  fertK                                   Float  @map("fert_k")
  fertS                                   Float  @map("fert_s")
  weedDiseaseActiveIngred1                String @map("weed_disease_active_ingred_1")
  weedDiseaseActiveIngred2                String @map("weed_disease_active_ingred_2")
  weedDiseaseActiveIngred3                String @map("weed_disease_active_ingred_3")
  weedDiseaseActiveIngred4                String @map("weed_disease_active_ingred_4")
  weedDiseaseActiveIngred5                String @map("weed_disease_active_ingred_5")
  weedDiseaseActiveIngred1PercentByWeight Float  @map("weed_disease_active_ingred_1_percent_by_weight")
  weedDiseaseActiveIngred2PercentByWeight Float  @map("weed_disease_active_ingred_2_percent_by_weight")
  weedDiseaseActiveIngred3PercentByWeight Float  @map("weed_disease_active_ingred_3_percent_by_weight")
  weedDiseaseActiveIngred4PercentByWeight Float  @map("weed_disease_active_ingred_4_percent_by_weight")
  weedDiseaseActiveIngred5PercentByWeight Float  @map("weed_disease_active_ingred_5_percent_by_weight")
  applicationRate                         Float  @map("application_rate")
  applicationUnit                         String @map("application_unit")
  harvestMachine                          String @map("harvest_machine")
  harvestCrop1                            String @map("harvest_crop_1")
  harvestCrop2                            String @map("harvest_crop_2")
  harvestCrop3                            String @map("harvest_crop_3")
  harvestCrop1Yield                       Float  @map("harvest_crop_1_yield")
  harvestCrop2Yield                       Float  @map("harvest_crop_2_yield")
  harvestCrop3Yield                       Float  @map("harvest_crop_3_yield")
  sowingCrop1                             String @map("sowing_crop_1")
  sowingCrop2                             String @map("sowing_crop_2")
  sowingCrop3                             String @map("sowing_crop_3")
  sowingCrop1Density                      Float  @map("sowing_crop_1_density")
  sowingCrop2Density                      Float  @map("sowing_crop_2_density")
  sowingCrop3Density                      Float  @map("sowing_crop_3_density")

  // // describe each action - each action has different data needs
  // // QUESTION - should each action have a different table with some way of linking that to this by an indicator variable like an enum? except each enum has different fields
  //
  // // crop stage at time of action
  // crop_stage    CropStage
  // action_reason Reason?
  //
  // // Fertiliser application
  // fertiliser_name Fertiliser?
  // fertiliser_rate Float?
  //
  // // Herbicide application
  // herbicide_name Herbicide?
  // herbicide_rate Float?
  // target_weeds   Weeds[] // QUESTION want to make this optional...
  //
  // // Planting/seeding
  // crop_planted Crop?
  // density      Float?
  //
  // // Harvest
  // harvest_crop Crop?
  // yield        Float?
  //
  // // Biomass cut/assessment
  // area_cut Float?
  // biomass  Float?
  //
  // action_comments  String?
  // general_comments String?
}

model Product {
  id          Int         @id @default(autoincrement())
  name        String      @unique
  productType ProductType @map("product_type")
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")
  Action      Action[]

  @@index([productType])
  @@map("product")
}

enum ProductType {
  HERBICIDE
  FUNGICIDE
  MOLLUSCICIDE
  FERTILISER
  INSECTICIDE
}

enum EventType {
  RAINFALL
  HAIL
}

enum Fertiliser {
  FERT1
  FERT2
}

enum CropStage {
  STAGE1
  STAGE2
}

enum Herbicide {
  HERB1
  HERB2
}

enum Reason {
  REASON1
  REASON2
}

enum Crop {
  CROP1
  CROP2
}

enum Weeds {
  WEED1
  WEED2
}
